import socket
import threading
from time import sleep

# В этой библиотеке все чтобы создать сокет

# Создадим сокет с яндексом и пошлем туда запрос чтобы получить на выходе главную старничку яндекса

ya_socket = socket.socket(socket.AF_INET)
# по умолчанию создается сокет TCP в адресном пространстве IPv4. Читать документацию


# Вызовем функцию которая сконнектит конектится к сайту ya.ru. Требуется структура адрес. Это массив соответствующего вида: IP-адрес и port.
# Указываем то, что требуется нам.

address = ("5.255.255.242", 443)
ya_socket.connect(address)

# После прохождения  .connect() у нас установится наш сокет

# Попробуем что то оправить
# Отправлять будет http-запросом в текстовом виде. Нужно будет перевести в двоичный вид
# Для перевода в двоичный вид в питоне ставится символ b

data_out = b"GET / HTTP/1.1\r\nHost:ya.ru\r\n\r\n"
# в http-запросе указываем: "МЕТОД запроса /(это корень) а указываем url запроса потом указываем HTTP-версию 1.1 и тд с переводами корректки см выше"
# Именно в таком виде на уровне L7 от нас улетает запрос к оперделенной старничке на определнном веб сервере

#data_out готова, отправим ее в наш сокет

ya_socket.send(data_out)
# после этого от нас удетит запрос на яндекс

#теперь перехватим ответ и как то это выразим
# для этого етсь функция - .recv() ей надо передать буфер - по скольку байт она будет перехватывать с нашей сетевой карты
# на сетевой карет есть буфер куда прилитают данные. А эта функция забирает из сетевой карты по 1024 байта и заносит в какую-то переменную
# мы создадим эту переменную data_in
datAa_in = ya_socket.recv(1024)
print(datAa_in)

# Код ответа от HTTP сервера 200 - это успешный код, означает, что страничка существует. 
# и ответ прерывается. Попробуем увелиячить буфер. Увеличивая видим, что начинает отражаться веб страница.
# Увеличение последующее нас не спасет - конец кода не увидим

# Попробуем посмотерть чем заканчивается код на самой странице. Через F12 смотрим код страницы.
# Это для html страницы закрывающие теги /<body> /<html>
# А не увидим, тк пакеты на сетевую карту приходят с некоторым отстававнием и буфер не усмевает заполниться
# Мы можем можем выставлять буфер размером кратный степени двойки и повторять
# копипастить или циклом
# он называет эти куки буфера ЧАНК

# чтобы выйти из бесконечного цикла - создадим функцию и вызовем ее в отдельном потоке
# импортируем библиотеку threading - библиотека для многопоточности
# создадим отдельный поток. и в таргете указываем имя функции. и даем отдельное имя этому потоку


data_in = b""
def recieving(): 
    while True:
        # тк переменная в области фидимости функции, а объявлядли ее раньше, то делаем ее global
        global data_in
        data_chunk = ya_socket.recv(1024)
        data_in = data_in + data_chunk

rec_threading = threading.Thread(target=recieving)
#этот поток надо стартануть
rec_threading.start()

# и после этого выполнение кода продолжается и сразу пойдет печать print(data_in)
# это не всегда нам нужно, тк прием может идти сколь угодно времени
# а код начнется печататься быстро
# поэтому воспользуемся функцией sleep() на 4 секудны. Функцию тоже надо импортировать (IDE само импортирует)

sleep(4)
print(data_in)

# страница отразилась полностью - видим закрывающие теги и теги из запроса: </body></html>\r\n0\r\n\r\n'
# но пограмма работает дальше
# закроем сокет
ya_socket.close()